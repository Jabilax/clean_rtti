 //------------------------------------------------------------------------------  
 // <auto-generated>                                                               
 //    This code was generated from a parser.                                      
 //                                                                                
 //    Manual changes to this file will be overwritten if the code is regenerated. 
 // </auto-generated>                                                              
 //------------------------------------------------------------------------------  

#pragma once
#include <array>
#include <vector>
#include <cassert>
#include <unordered_map>
#include <type_traits>

// Forward declarations and aliases.
struct Attribute;
using Args = std::vector<const char*>;
using Attributes = Attribute;//std::vector<Attribute>;

// Base reflect class. Using T2 to be able to specialize
// without fulling specializing the template.
template<class T2, class T = T2>
class Reflect
{
};

struct Attribute
{
    const char* name;
    //std::vector<const char*> arguments;
};

template<class T>
struct EnumValue 
{
    const char* name;
    T value;
};

template<class T>
class MemberVariable
{
private:
    constexpr MemberVariable(int index, const char* name, Attributes attr)
        : name{ name }
        , index{ index }
        , attributes{ attr }
    {
    }

public:
    template<class Fn>
    void apply(T& object, Fn callback) const
    {
        Reflect<T>::apply_variable(object, index, callback);
    }

    template<class R>
    R& get(T& object) const
    {
        return Reflect<T>::template get_variable<R>(object, index);
    }

public:
    const char* name;
    Attributes attributes;

private:
    int index;

    friend class Reflect<T>;
};

template<class T>
class MemberFunction
{
public:
    constexpr MemberFunction(int index, const char* name, Attributes attr)
        : name{ name }
        , index{ index }
        , attributes{ attr }
    {
    }

    template<class... ArgTypes>
    auto call(const T& object, ArgTypes... args)
    {
        return Reflect<T>::call(object, index, args...);
    }

public:
    const char* name;
    Attributes attributes;

private:
    int index;
};


struct Person;

template<class T>
class ReflectBase
{
public:
    template<class R>
    static R& get_variable(const char* variable_name, T& object)
    {
        return get_variable<R>(object, Reflect<T>::variable_map[variable_name]);
    }

    template<class R = void, class... Args>
    static R call(const char* function_name, T& object, Args... args)
    {
        const auto function_index = Reflect<T>::variable_map[function_name];
        return call<R>(function_index, object, args...);
    }

    static const MemberVariable<T>& get_variable(const char* variable_name)
    {
        return Reflect<T>::variables[Reflect<T>::variable_map[variable_name]];
    }

    static const MemberFunction<T>& get_function(const char* function_name)
    {
        return Reflect<T>::functions[Reflect<T>::function_map[function_name]];
    }

protected:
    template<class R>
    static R& get_variable(T& object, int variable_index)
    {
        void* var{ nullptr };
        auto lambda_get_var = [&var](auto& v) { var = &v; };
        Reflect<T>::apply_variable(object, variable_index, lambda_get_var);
        return *static_cast<R*>(var);
    }

    template<class R, class... Args>
    static R call(int function_index, T& object, Args... args)
    {
        using FunctPtr = R(T::*)(Args...);
        auto void_function = Reflect<T>::get_function(function_index);
        auto function = *(FunctPtr*)&void_function;
        return (object.*function)(args...); // try static pattern 
    }
};


template<class T>
class Reflect<Person, T> : public ReflectBase<T>
{
public:
    static constexpr const char* name{ "Person" };

    static Attributes attributes;
    static std::array<MemberVariable<T>, 2> variables;
    static std::array<MemberFunction<T>, 2> functions;

private:
    static std::unordered_map<const char*, int> variable_map;
    static std::unordered_map<const char*, int> function_map;

    template<class Fn>
    static void apply_variable(T& object, int variable_index, Fn callback);
    static void* get_function(int function_index);

    friend class MemberVariable<T>;
    friend class MemberFunction<T>;
    friend class ReflectBase<T>;
};

Attributes Reflect<Person>::attributes{};

std::array<MemberFunction<Person>, 2> Reflect<Person>::functions
{
    MemberFunction<Person>{0, "foo", Attributes{}},
    MemberFunction<Person>{1, "bar", Attributes{}},
};

std::array<MemberVariable<Person>, 2> Reflect<Person>::variables
{
    MemberVariable<Person>{0, "name", Attributes{}},
    MemberVariable<Person>{1, "age",  Attributes{}},
};

std::unordered_map<const char*, int> Reflect<Person>::variable_map
{
    {"name", 0},
    {"age", 1},
};

std::unordered_map<const char*, int> Reflect<Person>::function_map
{
    {"foo", 0},
    {"bar", 1},
};

template<class T> template<class Fn>
void Reflect<Person, T>::apply_variable(T& object, int variable_index, Fn callback)
{
    switch (variable_index)
    {
    case 0: callback(object.name); return;
    case 1: callback(object.age); return;
    }
    assert(false); // This shouldn't be possible.
}

template<class T>
void* Reflect<Person, T>::get_function(int function_index)
{
    switch (function_index)
    {
    case 0: {auto func = &T::foo; return *(void**)&func; }
    case 1: {auto func = &T::bar; return *(void**)&func; }
    }
    assert(false); // This shouldn't be possible.
    return nullptr;
}