#include "parser/generator.h"
#include "parser/parser.h"
#include <fstream>
#include <string>


const char* file_comment
{
    " //------------------------------------------------------------------------------  \n"
    " // <auto-generated>                                                               \n"
    " //    This code was generated from a parser.                                      \n"
    " //                                                                                \n"
    " //    Manual changes to this file will be overwritten if the code is regenerated. \n"
    " // </auto-generated>                                                              \n"
    " //------------------------------------------------------------------------------  \n"
};

void generate_reflection_info(std::ofstream& file, const ParsedData& data);

void generate_file_reflection_info(const fs::path& path, ParsedData& parsing_data)
{
    // Get the name of the meta file.
    const std::string root = "c:\\repositories\\clean_rtti\\include\\generated\\";
    const auto filename = "reflection_generated_" + path.stem().string() + ".h";

    // Open the meta file and write the autogenerated header comment.
    const auto reflection_file_path = root + filename;
    std::ofstream reflection_file{ reflection_file_path };
    reflection_file << file_comment;
    generate_reflection_info(reflection_file, parsing_data);
}

void generate_file_reflection_header(const std::vector<fs::path>& files)
{
    const std::string root = "c:\\repositories\\clean_rtti\\include\\generated\\";
    const auto filename = "reflection_generated.h";

    // Open the meta file and write the autogenerated header comment.
    const auto reflection_file_path = root + filename;
    std::ofstream reflection_file{ reflection_file_path };
    reflection_file << file_comment;
    reflection_file << "#pragma once" << "\n\n";

    for (auto file : files)
    {
        const auto meta_file = "reflection_generated_" + file.stem().string() + ".h";
        reflection_file << "#include \"" << meta_file << "\"\n";
    }
}



std::size_t replace_all(std::string& inout, std::string_view what, std::string_view with)
{
    std::size_t count{};
    for (std::string::size_type pos{}; inout.npos != (pos = inout.find(what.data(), pos, what.length())); pos += with.length(), ++count)
    {
        inout.replace(pos, what.length(), with.data(), with.length());
    }
    return count;
}

// Forward declarations
// ------------------------------------------------------------------------------------
void generate_reflection_info(std::ofstream& file, const ParsedData& data);
void generate_enum_reflection_info(std::ofstream& file, const ParsedData& data);
void generate_class_reflection_info(std::ofstream& file, const ParsedData& data);

// struct generators
void generate_forward_declare(std::ofstream& file, const Class& _class);
void generate_name(std::ofstream& file, const Class& _class);
void generate_attributes(std::ofstream& file, const Class& _class);
void generate_variable_num(std::ofstream& file, const Class& _class);
void generate_variable_name(std::ofstream& file, const Class& _class);
void generate_variable_attributes(std::ofstream& file, const Class& _class);
void generate_variable_value(std::ofstream& file, const Class& _class);
void generate_variable_apply(std::ofstream& file, const Class& _class);
void generate_function_num(std::ofstream& file, const Class& _class);
void generate_function_name(std::ofstream& file, const Class& _class);
void generate_function_attributes(std::ofstream& file, const Class& _class);
void generate_function_call(std::ofstream& file, const Class& _class);

// Helpers
auto type_name(const Class& _class) -> std::string;
void generate_attributes(std::ofstream& file, const std::vector<Attribute>& attributes, int tabs);

// ------------------------------------------------------------------------------------

void generate_reflection_info(std::ofstream& file, const ParsedData& data)
{
    file << "#pragma once\n";
    file << "#include \"../reflection_forward.h\"\n\n";

    generate_enum_reflection_info(file, data);
    generate_class_reflection_info(file, data);
}

void generate_enum_reflection_info(std::ofstream& /*file*/, const ParsedData& /*data*/)
{
}

void generate_class_reflection_info(std::ofstream& file, const ParsedData& data)
{
    for (auto& _class : data.classes)
    {
        generate_forward_declare(file, _class);

        file << "template<class T>\n";
        file << "struct Reflect<" << type_name(_class) << ", T>\n";
        file << "{\n";

        generate_name(file, _class);
        generate_attributes(file, _class);
        generate_variable_num(file, _class);
        generate_variable_name(file, _class);
        generate_variable_attributes(file, _class);
        generate_variable_value(file, _class);
        generate_variable_apply(file, _class);
        generate_function_num(file, _class);
        generate_function_name(file, _class);
        generate_function_attributes(file, _class);
        generate_function_call(file, _class);

        file << "};\n\n\n";
    }
}

void generate_forward_declare(std::ofstream& file, const Class& _class)
{
    if (!_class._namespace.empty())
    {
        file << "namespace " << _class._namespace << " { " << _class.type << " " << _class.name << "; }" << "\n";
    }
    else
    {
        file << _class.type << " " << _class.name << ";" << "\n";
    }

    file << "\n";
}

void generate_name(std::ofstream& file, const Class& _class)
{
    file << "    static auto name() -> std::string\n";
    file << "    {\n";
    file << "        return \"" << _class.name << "\";\n";
    file << "    }\n\n";
}

void generate_attributes(std::ofstream& file, const Class& _class)
{
    file << "    static auto attributes() -> const AttributeMap&\n";
    file << "    {\n";
    file << "        static AttributeMap attribute_map\n";
    generate_attributes(file, _class.attributes, 2); file << ";\n";
    file << "        return attribute_map;\n";
    file << "    }\n\n";
}

void generate_variable_num(std::ofstream& file, const Class& _class)
{
    file << "    static auto variable_num() -> int\n";
    file << "    {\n";
    file << "        return " << _class.variables.size() << ";\n";
    file << "    }\n\n";
}

void generate_variable_name(std::ofstream& file, const Class& _class)
{
    file << "    static auto variable_name(int index) -> std::string\n";
    file << "    {\n";
    file << "        std::string variable_names[]\n";
    file << "        {\n";
    for (const auto& var : _class.variables)
    file << "            \"" << var.name << "\",\n";
    file << "        };\n";
    file << "        return variable_names[index];\n";
    file << "    }\n\n";
}

void generate_variable_attributes(std::ofstream& file, const Class& _class)
{
    file << "    static auto variable_attributes(int index) -> const AttributeMap&\n";
    file << "    {\n";
    file << "        static AttributeMap attributes[]\n";
    file << "        {\n";
    for (const auto& var : _class.variables)
    {
        generate_attributes(file, var.attributes, 3);
        file << ",\n";
    }
    file << "        };\n";
    file << "        return attributes[index];\n";
    file << "    }\n\n";
}

void generate_variable_value(std::ofstream& file, const Class& _class)
{
    file << "    template<class Var>\n";
    file << "    static auto variable(T& instance, int index) -> Var&\n";
    file << "    {\n";
    file << "        static std::function<std::any(T&)> variables[]\n";
    file << "        {\n";
    for (const auto& var : _class.variables)
    file << "            [] (T& i) { return std::any(&i." << var.name << "); },\n";
    file << "        };\n";
    file << "        return *std::any_cast<Var*>(variables[index](instance));\n";
    file << "    }\n\n";
}

void generate_variable_apply(std::ofstream& file, const Class& _class)
{
    file << "    template<class Fn>\n";
    file << "    static void variable_apply(T & instance, int index, Fn function)\n";
    file << "    {\n";
    file << "        static std::function<void(T&, Fn)> apply_variables[]\n";
    file << "        {\n";
    for (const auto& var : _class.variables)
    file << "            [](T& i, Fn fn) { return fn(i." << var.name << "); },\n";
    file << "        };\n";
    file << "        return apply_variables[index](instance, function);\n";
    file << "    }\n\n";
}

void generate_function_num(std::ofstream& file, const Class& _class)
{
    file << "    static auto function_num() -> int\n";
    file << "    {\n";
    file << "        return " << _class.functions.size() << ";\n";
    file << "    }\n\n";
}

void generate_function_name(std::ofstream& file, const Class& _class)
{
    file << "    static auto function_name(int index) -> std::string\n";
    file << "    {\n";
    file << "        std::string function_names[]\n";
    file << "        {\n";
    for (const auto& function : _class.functions)
        file << "            \"" << function.name << "\",\n";
    file << "        };\n";
    file << "        return function_names[index];\n";
    file << "    }\n\n";
}

void generate_function_attributes(std::ofstream& file, const Class& _class)
{
    file << "    static auto function_attributes(int index) -> const AttributeMap&\n";
    file << "    {\n";
    file << "        static AttributeMap attributes[]\n";
    file << "        {\n";
    for (const auto& function : _class.functions)
    {
        generate_attributes(file, function.attributes, 3);
        file << ",\n";
    }
    file << "        };\n";
    file << "        return attributes[index];\n";
    file << "    }\n\n";
}

void generate_function_call(std::ofstream& file, const Class& _class)
{
    file << "    template<class Ret, typename... Args>\n";
    file << "    static auto function_call(T& instance, int index, Args&&... args) -> Ret\n";
    file << "    {\n";
    file << "        static std::function<std::any(T&, Args&&... args)> call_functions[]\n";
    file << "        {\n";
    for (const auto& function : _class.functions)
    file << "            [](T& i, Args&&... args){ return call_member_function<decltype(&T::" << function.name << "), T, Args...>(&T::" << function.name << ", i, std::forward<Args>(args)...); },\n";
    file << "        };\n";
    file << "        return cast_return_type<Ret>(call_functions[index](instance, std::forward<Args>(args)...));\n";
    file << "    }\n\n";
}

auto type_name(const Class& _class) -> std::string
{
    if (_class._namespace.empty())
    {
        return _class.name;
    }
    else
    {
        return _class._namespace + "::" + _class.name;
    }
}

void generate_attributes(std::ofstream& file, const std::vector<Attribute>& attributes, int tabs)
{
    auto indent = std::string(tabs * 4, ' ');

    file << indent << "{\n";
    for (const auto& attribute : attributes)
    {
        file << indent << "    {\"" << attribute.name << "\", AttributeArguments{";
        for (const auto& argument : attribute.arguments)
            file << argument << ", ";
        file << "}},\n";
    }
    file << indent << "}";
}