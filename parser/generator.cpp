#include "parser/generator.h"
#include "parser/parser.h"
#include <fstream>
#include <string>


const char* file_comment
{
    " //------------------------------------------------------------------------------  \n"
    " // <auto-generated>                                                               \n"
    " //    This code was generated from a parser.                                      \n"
    " //                                                                                \n"
    " //    Manual changes to this file will be overwritten if the code is regenerated. \n"
    " // </auto-generated>                                                              \n"
    " //------------------------------------------------------------------------------  \n"
};

void generate_reflection_info(std::ofstream& file, const ParsedData& data);

void generate_file_reflection_info(const fs::path& path, ParsedData& parsing_data)
{
    // Get the name of the meta file.
    const std::string root = "C:\\Repositories\\clean_rtti\\include\\generated\\";
    const auto filename = "reflection_generated_" + path.stem().string() + ".h";

    // Open the meta file and write the autogenerated header comment.
    const auto reflection_file_path = root + filename;
    std::ofstream reflection_file{ reflection_file_path };
    reflection_file << file_comment;
    generate_reflection_info(reflection_file, parsing_data);
}

void generate_file_reflection_header(const std::vector<fs::path>& files)
{
    const std::string root = "C:\\Repositories\\clean_rtti\\include\\generated\\";
    const auto filename = "reflection_generated.h";

    // Open the meta file and write the autogenerated header comment.
    const auto reflection_file_path = root + filename;
    std::ofstream reflection_file{ reflection_file_path };
    reflection_file << file_comment;
    reflection_file << "#pragma once" << "\n\n";

    for (auto file : files)
    {
        const auto meta_file = "reflection_generated_" + file.stem().string() + ".h";
        reflection_file << "#include \"" << meta_file << "\"\n";
    }
}



std::size_t replace_all(std::string& inout, std::string_view what, std::string_view with)
{
    std::size_t count{};
    for (std::string::size_type pos{}; inout.npos != (pos = inout.find(what.data(), pos, what.length())); pos += with.length(), ++count)
    {
        inout.replace(pos, what.length(), with.data(), with.length());
    }
    return count;
}

// Forward declarations
// ------------------------------------------------------------------------------------
void generate_reflection_info(std::ofstream& file, const ParsedData& data);
void generate_enum_reflection_info(std::ofstream& file, const ParsedData& data);
void generate_struct_reflection_info(std::ofstream& file, const ParsedData& data);

// struct generators
void generate_forward_declare(std::ofstream& file, const Struct& _struct);
void generate_reflect_name(std::ofstream& file, const Struct& _struct);
void generate_variables(std::ofstream& file, const Struct& _struct);

// Helpers
auto type_name(const Struct& _struct) -> std::string;
// ------------------------------------------------------------------------------------

void generate_reflection_info(std::ofstream& file, const ParsedData& data)
{
    file << "#pragma once\n";
    file << "#include \"../reflection_forward.h\"\n\n";

    generate_enum_reflection_info(file, data);
    generate_struct_reflection_info(file, data);
}

void generate_enum_reflection_info(std::ofstream& /*file*/, const ParsedData& /*data*/)
{
}

void generate_struct_reflection_info(std::ofstream& file, const ParsedData& data)
{
    for (auto& _struct : data.structs)
    {
        generate_forward_declare(file, _struct);
        generate_reflect_name(file, _struct);
        generate_variables(file, _struct);
        file << "\n";
    }
}

void generate_forward_declare(std::ofstream& file, const Struct& _struct)
{
    if (!_struct.namespace_scope.empty())
    {
        file << "namespace " << _struct.namespace_scope << " { " << _struct.type << " " << _struct.name << "; }" << "\n";
    }
    else
    {
        file << _struct.type << " " << _struct.name << ";" << "\n";
    }
}

void generate_reflect_name(std::ofstream& file, const Struct& _struct)
{
    file << "template<class T> ";
    file << "auto reflect_name() -> Specialize<" << type_name(_struct) << ", T, std::string> ";
    file << "{ return \"" << _struct.name << "\";" << " }\n";
}

void generate_variables(std::ofstream& file, const Struct& _struct)
{
    for (auto i = 0; i < _struct.variables.size(); ++i)
    {
    const auto& var = _struct.variables[i];

    file << "template<class T, int index> ";
    file << "auto reflect_variable_name() -> SpecializeIndex<" << type_name(_struct) << ", T, " << i << ", index, std::string> ";
    file << "{ return \"" << var.name << "\"; }\n";
    }


    //auto _array = "std::array<" + std::to_string(_struct.variables.size()) + ">";
    //
    //file << "template<class T>" << "\n";
    //file << "auto reflect_variables() -> Specialize<" << type_name(_struct) << ", T, const " << _array << ">" << "\n";
    //file << "{" << "\n";
    //file << "    static std::vector<MemberVariable<T>> variables" << "\n";
    //file << "    {" << "\n";
    //
    //for (const auto& var : _struct.variables)
    //{
    //file << "        MemberVariable<T>{}," << "\n";
    //}
    //file << "    };" << "\n";
    //file << "    return variables;" << "\n";
    //file << "}" << "\n\n";
}

auto type_name(const Struct& _struct) -> std::string
{
    if (_struct.namespace_scope.empty())
    {
        return _struct.name;
    }
    else
    {
        return _struct.namespace_scope + "::" + _struct.name;
    }
}