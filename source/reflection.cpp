#include "reflection.h"
#include "parser.h"
#include <fstream>
#include <string>

std::size_t replace_all(std::string& inout, std::string_view what, std::string_view with)
{
    std::size_t count{};
    for (std::string::size_type pos{}; inout.npos != (pos = inout.find(what.data(), pos, what.length())); pos += with.length(), ++count)
    {
        inout.replace(pos, what.length(), with.data(), with.length());
    }
    return count;
}

const char* file_comment
{
    " //------------------------------------------------------------------------------  \n"
    " // <auto-generated>                                                               \n"
    " //    This code was generated from a parser.                                      \n"
    " //                                                                                \n"
    " //    Manual changes to this file will be overwritten if the code is regenerated. \n"
    " // </auto-generated>                                                              \n"
    " //------------------------------------------------------------------------------  \n"
};

void generate_reflection_info(std::ofstream& file, const ParsedData& data);
void generate_enum_reflection_info(std::ofstream& file, const ParsedData& data);
void generate_struct_reflection_info(std::ofstream& file, const ParsedData& data);

void generate_reflection_info(const fs::path& file_path, const ParsedData& data)
{
    // Get the name of the meta file.
    const std::string root = "C:\\Repositories\\clean_rtti\\tests\\";
    const std::string filename = "reflection.h";

    // Open the meta file and write the autogenerated header comment.
    const auto reflection_file_path = root + filename;
    std::ofstream reflection_file{ reflection_file_path };
    reflection_file << file_comment << "\n";
    generate_reflection_info(reflection_file, data);
}

void generate_reflection_info(std::ofstream& file, const ParsedData& data)
{
    file << "#pragma once\n";
    file << "#include <array>\n";
    file << "#include <vector>\n\n";

    file << "template<class T2, class T = T2> struct Reflect {};\n";
    file << "template<class T2, class T = T2> struct MemberVariable {};\n";
    file << "template<class T> struct EnumValue { const char* name; T value; };\n";
    file << "struct Attribute { const char* name; std::vector<const char*> arguments; };\n\n";

    generate_enum_reflection_info(file, data);
    generate_struct_reflection_info(file, data);
}

void generate_enum_reflection_info(std::ofstream& file, const ParsedData& data)
{
    for (auto& enum_type : data.enums)
    {
    if(!enum_type.namespace_scope.empty())
    {
    file << "namespace " << enum_type.namespace_scope << "\n";
    file << "{\n    ";
    }
    file << "enum " << (enum_type.is_enum_class ? "class " : "") << enum_type.name << " : " << enum_type.type << ";\n";
    if (!enum_type.namespace_scope.empty())
    file << "}\n\n";
    else
    file << "\n";

    file << "template<class T>\n";
    file << "struct Reflect<" << (enum_type.namespace_scope.empty() ? "" : enum_type.namespace_scope + "::") + enum_type.name << ", T>\n";
    file << "{\n";
    file << "    static constexpr const char* name{ \"" << enum_type.name << "\" };\n";
    file << "    static constexpr std::array<EnumValue<T>, " << enum_type.values.size() << "> values\n";
    file << "    {\n";
    for (auto& value : enum_type.values)
    file << "        EnumValue<T>{\"" << value << "\", T::" << value << "},\n";
    file << "    };\n";
    file << "};\n\n";
    }
}

void generate_struct_reflection_info(std::ofstream& file, const ParsedData& data)
{
    for (auto& struct_type : data.structs)
    {
    if(!struct_type.namespace_scope.empty())
    {
    file << "namespace " << struct_type.namespace_scope << "\n";
    file << "{\n    ";
    }
    file << struct_type.type << " " << struct_type.name << ";\n";
    if (!struct_type.namespace_scope.empty())
    file << "}\n\n";
    else
    file << "\n";

    file << "template<class T>\n";
    file << "struct MemberVariable<" << struct_type.name << ", T>\n";
    file << "{\n";
    file << "    constexpr MemberVariable(const char* name, int index) : name{ name }, index{ index } {}\n\n";

    // ---------------------------------------------- Get variable ------------------------------------------------
    file << "    template<class Fn>\n";
    file << "    void get(const T& object, Fn callback) const\n";
    file << "    {\n";
    file << "        switch (index)\n";
    file << "        {\n";
    for (int i = 0; auto& var : struct_type.variables)
    file << "        case " << i++ << ": callback(object." << var.name << "); break;\n";
    file << "        }\n";
    file << "    }\n\n";

    // ------------------------------------------------ Attributes ------------------------------------------------
    file << "    auto attributes() -> std::vector<Attribute> const\n";
    file << "    {\n";
    file << "        switch (index)\n";
    file << "        {\n";
    for (int i = 0; auto& var : struct_type.variables)
    {
    if(!var.attributes.empty())
    {
    file << "        case " << i++ << ": return std::vector<Attribute> {\n";
    for (auto& attribute : var.attributes)
    file << "                Attribute{\"" << attribute.name << "\", std::vector<const char*>{}},\n";
    file << "            };\n";
    }
    }
    file << "        }\n";
    file << "        return std::vector<Attribute>{};\n";
    file << "    }\n\n";

    file << "    const char* name;\n\n";

    file << "private:\n";
    file << "    int index;\n";
    file << "};\n\n";

    file << "template<class T>\n";
    file << "struct Reflect<" << (struct_type.namespace_scope.empty() ? "" : struct_type.namespace_scope + "::") + struct_type.name << ", T>\n";
    file << "{\n";
    file << "    static constexpr const char* name{ \"" << struct_type.name << "\" };\n";
    file << "    static constexpr std::array<MemberVariable<T>, " << struct_type.variables.size() << "> variables\n";
    file << "    {\n";
    for (int i = 0; auto& var : struct_type.variables)
    file << "        MemberVariable<T>{\"" << var.name << "\", " << i++ << "},\n";
    file << "    };\n";
    file << "};\n\n";
    }
}