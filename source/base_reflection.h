 //------------------------------------------------------------------------------  
 // <auto-generated>                                                               
 //    This code was generated from a parser.                                      
 //                                                                                
 //    Manual changes to this file will be overwritten if the code is regenerated. 
 // </auto-generated>                                                              
 //------------------------------------------------------------------------------  

#pragma once
#include <array>
#include <vector>
#include <cassert>
#include <unordered_map>

// Forward declarations and aliases.
struct Attribute;
using Args = std::vector<const char*>;
using Attributes = std::vector<Attribute>;

// Base reflect class. Using T2 to be able to specialize
// without fulling specializing the template.
template<class T2, class T = T2>
class Reflect
{
};

struct Attribute
{
    const char* name;
    std::vector<const char*> arguments;
};

template<class T>
struct EnumValue 
{
    const char* name;
    T value;
};

template<class T>
class MemberVariable
{
public:
    constexpr MemberVariable(int index, const char* name, Attributes attr)
        : name{ name }
        , index{ index }
        , attributes{ attr }
    {
    }

    template<class Fn>
    auto apply(T& object, Fn callback)
    {
        return Reflect<T>::apply(object, index, callback);
    }

    template<class R>
    R& get(const T& object)
    {
        return Reflect<T>::template get_variable<R>(object, index);
    }

public:
    const char* name;
    Attributes attributes;

private:
    int index;
};

template<class T>
class MemberFunction
{
public:
    constexpr MemberFunction(int index, const char* name, Attributes attr)
        : name{ name }
        , index{ index }
        , attributes{ attr }
    {
    }

    template<class... ArgTypes>
    auto call(const T& object, ArgTypes... args)
    {
        return Reflect<T>::call(object, index, args...);
    }

public:
    const char* name;
    Attributes attributes;

private:
    int index;
};

struct Person;

template<class T>
class ReflectBase
{
public:
    template<class R>
    static R& get_variable(T& object, const char* variable_name)
    {
        return get_variable<R>(object, Reflect<T>::get_variable_map()[variable_name]);
    }

    template<class R>
    static R* get_function(const char* function_name)
    {
        return Reflect<T>::apply_function(Reflect<T>::get_function_map()[function_name], [](R* func) {return func; });
    }

    static const MemberVariable<T>& get_variable(const char* variable_name)
    {
        return Reflect<T>::variables[Reflect<T>::get_variable_map()[variable_name]];
    }

    static const MemberFunction<T>& get_function(const char* function_name)
    {
        return Reflect<T>::functions[Reflect<T>::get_function_map()[function_name]];
    }

protected:
    template<class R>
    static R& get_variable(T& object, int variable_index)
    {
        return *(R*)Reflect<T>::get_variable_ptr(object, variable_index);
    }

    template<class R>
    static R& get_function(int function_index)
    {
        return *(R*)Reflect<T>::get_function_ptr(function_index);
    }
};


template<class T>
class Reflect<Person, T> : public ReflectBase<T>
{
public:
    static constexpr const char* name{ "Person" };
    static constexpr Attribute attributes{};

    static constexpr std::array<MemberVariable<T>, 2> variables
    {
        MemberVariable<T>{0, "name", Attributes{}},
        MemberVariable<T>{1, "age",  Attributes{}},
    };

    static constexpr std::array<MemberFunction<T>, 2> functions
    {
        MemberFunction<T>{0, "foo", Attributes{}},
        MemberFunction<T>{1, "bar", Attributes{}},
    };

private:
    static auto get_variable_map()
    {
        static std::unordered_map<const char*, int> variable_map
        {
            {"name", 0},
            {"age", 1},
        };

        return variable_map;
    }

    static auto get_function_map()
    {
        static std::unordered_map<const char*, int> variable_map
        {
            {"foo", 0},
            {"bar", 1},
        };

        return variable_map;
    }

    static void* get_variable_ptr(T& object, int var_index)
    {
        switch (var_index)
        {
        case 0: return &object.name;
        case 1: return &object.age;
        }
        assert(false); // This shouldn't be possible.
    }

    static void* get_function_ptr(int var_index)
    {
        switch (var_index)
        {
        case 0: return &T::foo;
        case 1: return &T::var;
        }
        assert(false); // This shouldn't be possible.
    }

    template<class Fn>
    static void apply(T& object, int var_index, Fn callback)
    {
        switch (var_index)
        {
        case 0: callback(object.name); return;
        case 1: callback(object.age); return;
        }
        assert(false); // This shouldn't be possible.
    }


    friend class MemberVariable<Person>;
    friend class MemberFunction<Person>;
    friend class ReflectBase<Person>;
};
