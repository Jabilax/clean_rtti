 //------------------------------------------------------------------------------  
 // <auto-generated>                                                               
 //    This code was generated from a parser.                                      
 //                                                                                
 //    Manual changes to this file will be overwritten if the code is regenerated. 
 // </auto-generated>                                                              
 //------------------------------------------------------------------------------  
#pragma once
#include "../reflection_forward.h"

struct Person;

template<class T>
struct Reflect<Person, T>
{
    static auto name() -> std::string
    {
        return "Person";
    }

    static auto variable_num() -> int
    {
        return 2;
    }

    static auto variable_name(int index) -> std::string
    {
        std::string variable_names[]
        {
            "name",
            "age",
        };
        return variable_names[index];
    }

    template<class Var>
    static auto variable(T& instance, int index) -> Var&
    {
        static std::function<std::any(T&)> variables[]
        {
            [] (T& i) { return std::any(&i.name); },
            [] (T& i) { return std::any(&i.age); },
        };
        return *std::any_cast<Var*>(variables[index](instance));
    }

    template<class Fn>
    static void variable_apply(T & instance, int index, Fn function)
    {
        static std::function<void(T&, Fn)> apply_variables[]
        {
            [](T& i, Fn fn) { return fn(i.name); },
            [](T& i, Fn fn) { return fn(i.age); },
        };
        return apply_variables[index](instance, function);
    }

    static auto function_num() -> int
    {
        return 1;
    }

    static auto function_name(int index) -> std::string
    {
        std::string function_names[]
        {
            "foo",
        };
        return function_names[index];
    }

    template<class Ret, typename... Args>
    static auto function_call(T& instance, int index, Args&&... args) -> Ret
    {
        auto call_function = [](auto function, auto& i, auto&&... args)
        {
            if constexpr (std::is_void_v<std::invoke_result_t<decltype(function)>>)
            {
                return std::any(std::invoke(function, i, std::forward<decltype(args)>(args)...));
            }
            else
            {
                return std::any(); std::invoke(function, i, std::forward<decltype(args)>(args)...);
            }
        };
    
        static std::function<std::any(T&, Args&&... args)> call_functions[]
        {
            [call_function](T& i, Args&&... args){ return call_function(&T::foo, i, std::forward<Args>(args)...); },
        };
        return std::any_cast<Ret>(call_functions[index](instance, std::forward<Args>(args)...));
    }

};


struct Human;

template<class T>
struct Reflect<Human, T>
{
    static auto name() -> std::string
    {
        return "Human";
    }

    static auto variable_num() -> int
    {
        return 2;
    }

    static auto variable_name(int index) -> std::string
    {
        std::string variable_names[]
        {
            "some_variable",
            "slider",
        };
        return variable_names[index];
    }

    template<class Var>
    static auto variable(T& instance, int index) -> Var&
    {
        static std::function<std::any(T&)> variables[]
        {
            [] (T& i) { return std::any(&i.some_variable); },
            [] (T& i) { return std::any(&i.slider); },
        };
        return *std::any_cast<Var*>(variables[index](instance));
    }

    template<class Fn>
    static void variable_apply(T & instance, int index, Fn function)
    {
        static std::function<void(T&, Fn)> apply_variables[]
        {
            [](T& i, Fn fn) { return fn(i.some_variable); },
            [](T& i, Fn fn) { return fn(i.slider); },
        };
        return apply_variables[index](instance, function);
    }

    static auto function_num() -> int
    {
        return 0;
    }

    static auto function_name(int index) -> std::string
    {
        std::string function_names[]
        {
        };
        return function_names[index];
    }

    template<class Ret, typename... Args>
    static auto function_call(T& instance, int index, Args&&... args) -> Ret
    {
        auto call_function = [](auto function, auto& i, auto&&... args)
        {
            if constexpr (std::is_void_v<std::invoke_result_t<decltype(function)>>)
            {
                return std::any(std::invoke(function, i, std::forward<decltype(args)>(args)...));
            }
            else
            {
                return std::any(); std::invoke(function, i, std::forward<decltype(args)>(args)...);
            }
        };
    
        static std::function<std::any(T&, Args&&... args)> call_functions[]
        {
        };
        return std::any_cast<Ret>(call_functions[index](instance, std::forward<Args>(args)...));
    }

};


struct Alien;

template<class T>
struct Reflect<Alien, T>
{
    static auto name() -> std::string
    {
        return "Alien";
    }

    static auto variable_num() -> int
    {
        return 0;
    }

    static auto variable_name(int index) -> std::string
    {
        std::string variable_names[]
        {
        };
        return variable_names[index];
    }

    template<class Var>
    static auto variable(T& instance, int index) -> Var&
    {
        static std::function<std::any(T&)> variables[]
        {
        };
        return *std::any_cast<Var*>(variables[index](instance));
    }

    template<class Fn>
    static void variable_apply(T & instance, int index, Fn function)
    {
        static std::function<void(T&, Fn)> apply_variables[]
        {
        };
        return apply_variables[index](instance, function);
    }

    static auto function_num() -> int
    {
        return 0;
    }

    static auto function_name(int index) -> std::string
    {
        std::string function_names[]
        {
        };
        return function_names[index];
    }

    template<class Ret, typename... Args>
    static auto function_call(T& instance, int index, Args&&... args) -> Ret
    {
        auto call_function = [](auto function, auto& i, auto&&... args)
        {
            if constexpr (std::is_void_v<std::invoke_result_t<decltype(function)>>)
            {
                return std::any(std::invoke(function, i, std::forward<decltype(args)>(args)...));
            }
            else
            {
                return std::any(); std::invoke(function, i, std::forward<decltype(args)>(args)...);
            }
        };
    
        static std::function<std::any(T&, Args&&... args)> call_functions[]
        {
        };
        return std::any_cast<Ret>(call_functions[index](instance, std::forward<Args>(args)...));
    }

};


