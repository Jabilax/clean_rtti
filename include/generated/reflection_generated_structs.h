 //------------------------------------------------------------------------------  
 // <auto-generated>                                                               
 //    This code was generated from a parser.                                      
 //                                                                                
 //    Manual changes to this file will be overwritten if the code is regenerated. 
 // </auto-generated>                                                              
 //------------------------------------------------------------------------------  
#pragma once
#include "../reflection_forward.h"

struct Person;

template<class T>
struct Reflect<Person, T>
{
    static auto name() -> std::string
    {
        return "Person";
    }

    static auto variable_num() -> int
    {
        return 2;
    }

    static auto variable_name(int index) -> std::string
    {
        std::string variable_names[]
        {
            "name",
            "age",
        };
        return variable_names[index];
    }

    template<class Var>
    static auto variable(T& instance, int index) -> Var&
    {
        static std::function<std::any(T&)> variables[]
        {
            [] (T& i) { return std::any(&i.name); },
            [] (T& i) { return std::any(&i.age); },
        };
        return *std::any_cast<Var*>(variables[index](instance));
    }

    static auto function_num() -> int
    {
        return 1;
    }

    static auto function_name(int index) -> std::string
    {
        std::string function_names[]
        {
            "foo",
        };
        return function_names[index];
    }

};


struct Human;

template<class T>
struct Reflect<Human, T>
{
    static auto name() -> std::string
    {
        return "Human";
    }

    static auto variable_num() -> int
    {
        return 2;
    }

    static auto variable_name(int index) -> std::string
    {
        std::string variable_names[]
        {
            "some_variable",
            "slider",
        };
        return variable_names[index];
    }

    template<class Var>
    static auto variable(T& instance, int index) -> Var&
    {
        static std::function<std::any(T&)> variables[]
        {
            [] (T& i) { return std::any(&i.some_variable); },
            [] (T& i) { return std::any(&i.slider); },
        };
        return *std::any_cast<Var*>(variables[index](instance));
    }

    static auto function_num() -> int
    {
        return 0;
    }

    static auto function_name(int index) -> std::string
    {
        std::string function_names[]
        {
        };
        return function_names[index];
    }

};


struct Alien;

template<class T>
struct Reflect<Alien, T>
{
    static auto name() -> std::string
    {
        return "Alien";
    }

    static auto variable_num() -> int
    {
        return 0;
    }

    static auto variable_name(int index) -> std::string
    {
        std::string variable_names[]
        {
        };
        return variable_names[index];
    }

    template<class Var>
    static auto variable(T& instance, int index) -> Var&
    {
        static std::function<std::any(T&)> variables[]
        {
        };
        return *std::any_cast<Var*>(variables[index](instance));
    }

    static auto function_num() -> int
    {
        return 0;
    }

    static auto function_name(int index) -> std::string
    {
        std::string function_names[]
        {
        };
        return function_names[index];
    }

};


