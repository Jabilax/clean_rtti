 //------------------------------------------------------------------------------  
 // <auto-generated>                                                               
 //    This code was generated from a parser.                                      
 //                                                                                
 //    Manual changes to this file will be overwritten if the code is regenerated. 
 // </auto-generated>                                                              
 //------------------------------------------------------------------------------  
#pragma once
#include "../reflection_forward.h"

struct Person;

template<class T>
struct Reflect<Person, T>
{
    static auto name() -> std::string
    {
        return "Person";
    }

    static auto attributes() -> const AttributeMap&
    {
        static AttributeMap attribute_map
        {
            {"editor::show", AttributeArguments{"name", 5.f, }},
            {"editor::serialize", AttributeArguments{}},
        };
        return attribute_map;
    }

    static auto variable_num() -> int
    {
        return 3;
    }

    static auto variable_name(int index) -> std::string
    {
        std::string variable_names[]
        {
            "name",
            "age",
            "my_array",
        };
        return variable_names[index];
    }

    static auto variable_attributes(int index) -> const AttributeMap&
    {
        static AttributeMap attributes[]
        {
            {
                {"some_attribute", AttributeArguments{}},
                {"hello", AttributeArguments{}},
            },
            {
            },
            {
                {"editor::serialize", AttributeArguments{5.f, }},
            },
        };
        return attributes[index];
    }

    template<class Var>
    static auto variable(T& instance, int index) -> Var&
    {
        static std::function<std::any(T&)> variables[]
        {
            [] (T& i) { return std::any(&i.name); },
            [] (T& i) { return std::any(&i.age); },
            [] (T& i) { return std::any(&i.my_array); },
        };
        return *std::any_cast<Var*>(variables[index](instance));
    }

    template<class Fn>
    static void variable_apply(T & instance, int index, Fn function)
    {
        static std::function<void(T&, Fn)> apply_variables[]
        {
            [](T& i, Fn fn) { return fn(i.name); },
            [](T& i, Fn fn) { return fn(i.age); },
            [](T& i, Fn fn) { return fn(i.my_array); },
        };
        return apply_variables[index](instance, function);
    }

    static auto function_num() -> int
    {
        return 3;
    }

    static auto function_name(int index) -> std::string
    {
        std::string function_names[]
        {
            "foo",
            "get_name",
            "bar",
        };
        return function_names[index];
    }

    static auto function_attributes(int index) -> const AttributeMap&
    {
        static AttributeMap attributes[]
        {
            {
            },
            {
            },
            {
            },
        };
        return attributes[index];
    }

    template<class Ret, typename... Args>
    static auto function_call(T& instance, int index, Args&&... args) -> Ret
    {
        static std::function<std::any(T&, Args&&... args)> call_functions[]
        {
            [](T& i, Args&&... args){ return call_member_function<decltype(&T::foo), T, Args...>(&T::foo, i, std::forward<Args>(args)...); },
            [](T& i, Args&&... args){ return call_member_function<decltype(&T::get_name), T, Args...>(&T::get_name, i, std::forward<Args>(args)...); },
            [](T& i, Args&&... args){ return call_member_function<decltype(&T::bar), T, Args...>(&T::bar, i, std::forward<Args>(args)...); },
        };
        return cast_return_type<Ret>(call_functions[index](instance, std::forward<Args>(args)...));
    }

};


struct Human;

template<class T>
struct Reflect<Human, T>
{
    static auto name() -> std::string
    {
        return "Human";
    }

    static auto attributes() -> const AttributeMap&
    {
        static AttributeMap attribute_map
        {
        };
        return attribute_map;
    }

    static auto variable_num() -> int
    {
        return 2;
    }

    static auto variable_name(int index) -> std::string
    {
        std::string variable_names[]
        {
            "some_variable",
            "slider",
        };
        return variable_names[index];
    }

    static auto variable_attributes(int index) -> const AttributeMap&
    {
        static AttributeMap attributes[]
        {
            {
            },
            {
            },
        };
        return attributes[index];
    }

    template<class Var>
    static auto variable(T& instance, int index) -> Var&
    {
        static std::function<std::any(T&)> variables[]
        {
            [] (T& i) { return std::any(&i.some_variable); },
            [] (T& i) { return std::any(&i.slider); },
        };
        return *std::any_cast<Var*>(variables[index](instance));
    }

    template<class Fn>
    static void variable_apply(T & instance, int index, Fn function)
    {
        static std::function<void(T&, Fn)> apply_variables[]
        {
            [](T& i, Fn fn) { return fn(i.some_variable); },
            [](T& i, Fn fn) { return fn(i.slider); },
        };
        return apply_variables[index](instance, function);
    }

    static auto function_num() -> int
    {
        return 0;
    }

    static auto function_name(int index) -> std::string
    {
        std::string function_names[]
        {
        };
        return function_names[index];
    }

    static auto function_attributes(int index) -> const AttributeMap&
    {
        static AttributeMap attributes[]
        {
        };
        return attributes[index];
    }

    template<class Ret, typename... Args>
    static auto function_call(T& instance, int index, Args&&... args) -> Ret
    {
        static std::function<std::any(T&, Args&&... args)> call_functions[]
        {
        };
        return cast_return_type<Ret>(call_functions[index](instance, std::forward<Args>(args)...));
    }

};


struct Alien;

template<class T>
struct Reflect<Alien, T>
{
    static auto name() -> std::string
    {
        return "Alien";
    }

    static auto attributes() -> const AttributeMap&
    {
        static AttributeMap attribute_map
        {
        };
        return attribute_map;
    }

    static auto variable_num() -> int
    {
        return 0;
    }

    static auto variable_name(int index) -> std::string
    {
        std::string variable_names[]
        {
        };
        return variable_names[index];
    }

    static auto variable_attributes(int index) -> const AttributeMap&
    {
        static AttributeMap attributes[]
        {
        };
        return attributes[index];
    }

    template<class Var>
    static auto variable(T& instance, int index) -> Var&
    {
        static std::function<std::any(T&)> variables[]
        {
        };
        return *std::any_cast<Var*>(variables[index](instance));
    }

    template<class Fn>
    static void variable_apply(T & instance, int index, Fn function)
    {
        static std::function<void(T&, Fn)> apply_variables[]
        {
        };
        return apply_variables[index](instance, function);
    }

    static auto function_num() -> int
    {
        return 0;
    }

    static auto function_name(int index) -> std::string
    {
        std::string function_names[]
        {
        };
        return function_names[index];
    }

    static auto function_attributes(int index) -> const AttributeMap&
    {
        static AttributeMap attributes[]
        {
        };
        return attributes[index];
    }

    template<class Ret, typename... Args>
    static auto function_call(T& instance, int index, Args&&... args) -> Ret
    {
        static std::function<std::any(T&, Args&&... args)> call_functions[]
        {
        };
        return cast_return_type<Ret>(call_functions[index](instance, std::forward<Args>(args)...));
    }

};


